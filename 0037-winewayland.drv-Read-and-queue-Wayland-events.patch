From f5917d5c01e83309a9715f8a55c3bb2d7a4f5860 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 14:37:22 +0300
Subject: [PATCH 037/165] winewayland.drv: Read and queue Wayland events.

Create a separate reader thread to read Wayland events from the
compositor, queue them to their appropriate queues and also dispatch
events for the per-process Wayland instance. The reader thread notifies
all Wayland-enabled threads of possible new events by using an unnamed
pipe for each thread. The read end of the pipe is used as the Wine
driver queue fd for the respective thread.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         | 61 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 +
 dlls/winewayland.drv/waylanddrv_main.c | 46 +++++++++++++++++++
 3 files changed, 109 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 138f24d48e8..a7289426ea4 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -25,8 +25,10 @@
 #include "wine/debug.h"
 
 #include <errno.h>
+#include <fcntl.h>
 #include <poll.h>
 #include <stdlib.h>
+#include <unistd.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
@@ -145,10 +147,13 @@ static const struct wl_registry_listener registry_listener = {
 BOOL wayland_init(struct wayland *wayland)
 {
     struct wl_display *wl_display_wrapper;
+    int flags;
 
     TRACE("wayland=%p wl_display=%p\n", wayland, process_wl_display);
 
     wl_list_init(&wayland->thread_link);
+    wayland->event_notification_pipe[0] = -1;
+    wayland->event_notification_pipe[1] = -1;
 
     wayland->process_id = GetCurrentProcessId();
     wayland->thread_id = GetCurrentThreadId();
@@ -195,6 +200,16 @@ BOOL wayland_init(struct wayland *wayland)
 
     if (!wayland_is_process(wayland))
     {
+        /* Thread wayland instances have notification pipes to inform them when
+         * there might be new events in their queues. The read part of the pipe
+         * is also used as the wine server queue fd. */
+        if (pipe2(wayland->event_notification_pipe, O_CLOEXEC) == -1)
+            return FALSE;
+        /* Make just the read end non-blocking */
+        if ((flags = fcntl(wayland->event_notification_pipe[0], F_GETFL)) == -1)
+            return FALSE;
+        if (fcntl(wayland->event_notification_pipe[0], F_SETFL, flags | O_NONBLOCK) == -1)
+            return FALSE;
         /* Keep a list of all thread wayland instances. */
         wayland_mutex_lock(&thread_wayland_mutex);
         wl_list_insert(&thread_wayland_list, &wayland->thread_link);
@@ -221,6 +236,11 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_remove(&wayland->thread_link);
     wayland_mutex_unlock(&thread_wayland_mutex);
 
+    if (wayland->event_notification_pipe[0] >= 0)
+        close(wayland->event_notification_pipe[0]);
+    if (wayland->event_notification_pipe[1] >= 0)
+        close(wayland->event_notification_pipe[1]);
+
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
@@ -300,6 +320,28 @@ void wayland_process_release(void)
     wayland_mutex_unlock(&process_wayland_mutex);
 }
 
+static void wayland_notify_threads(void)
+{
+    struct wayland *w;
+    int ret;
+
+    wayland_mutex_lock(&thread_wayland_mutex);
+
+    wl_list_for_each(w, &thread_wayland_list, thread_link)
+    {
+        while ((ret = write(w->event_notification_pipe[1], "a", 1)) != 1)
+        {
+            if (ret == -1 && errno != EINTR)
+            {
+                ERR("failed to write to notification pipe: %s\n", strerror(errno));
+                break;
+            }
+        }
+    }
+
+    wayland_mutex_unlock(&thread_wayland_mutex);
+}
+
 /**********************************************************************
  *          wayland_notify_wine_monitor_change
  *
@@ -405,7 +447,26 @@ int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms)
         return -1;
     }
 
+    /* We may have read and queued events in queues other than the specified
+     * one, so we need to notify threads (see wayland_read_events). */
+    wayland_notify_threads();
+
     TRACE("... done\n");
 
     return ret;
 }
+
+/**********************************************************************
+ *          wayland_read_events_and_dispatch_process
+ *
+ * Read wayland events from the compositor, place them in their proper
+ * event queues, dispatch any events for the per-process wayland instance,
+ * and notify threads about the possibility of new per-thread wayland instance
+ * events (without dispatching them).
+ *
+ * Returns whether the operation succeeded.
+ */
+BOOL wayland_read_events_and_dispatch_process(void)
+{
+    return (wayland_dispatch_queue(process_wayland->wl_event_queue, -1) != -1);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index dd5f30b0ac5..53509a57aec 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -97,6 +97,7 @@ struct wayland
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
+    int event_notification_pipe[2];
 };
 
 struct wayland_output_mode
@@ -251,6 +252,7 @@ struct wayland_output *wayland_output_get_by_wine_name(struct wayland *wayland,
  */
 
 int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms) DECLSPEC_HIDDEN;
+BOOL wayland_read_events_and_dispatch_process(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland surface
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index fcc4978a0f2..30586764f95 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -25,12 +25,52 @@
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
+#include "wine/server.h"
 
 #include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
+static DWORD WINAPI wayland_read_thread(void *arg)
+{
+    while (wayland_read_events_and_dispatch_process()) continue;
+    /* This thread terminates only if an unrecoverable error occured during
+     * event reading. */
+    exit(1);
+    return 0;
+}
+
+static void set_queue_fd(struct wayland *wayland)
+{
+    HANDLE handle;
+    int wfd;
+    int ret;
+
+    wfd = wayland->event_notification_pipe[0];
+
+    if (wine_server_fd_to_handle(wfd, GENERIC_READ | SYNCHRONIZE, 0, &handle))
+    {
+        ERR("Can't allocate handle for wayland fd\n");
+        ExitProcess(1);
+    }
+
+    SERVER_START_REQ(set_queue_fd)
+    {
+        req->handle = wine_server_obj_handle(handle);
+        ret = wine_server_call(req);
+    }
+    SERVER_END_REQ;
+
+    if (ret)
+    {
+        ERR("Can't store handle for wayland fd %x\n", ret);
+        ExitProcess(1);
+    }
+
+    CloseHandle(handle);
+}
+
 /***********************************************************************
  *           Initialize per thread data
  */
@@ -54,6 +94,7 @@ struct wayland_thread_data *wayland_init_thread_data(void)
         ExitProcess(1);
     }
 
+    set_queue_fd(&data->wayland);
     NtUserGetThreadInfo()->driver_data = data;
 
     return data;
@@ -92,10 +133,15 @@ static const struct user_driver_funcs waylanddrv_funcs =
  */
 static BOOL process_attach(void)
 {
+    DWORD id;
+
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
     if (!wayland_process_init()) return FALSE;
 
+    /* Read wayland events from a dedicated thread. */
+    CreateThread(NULL, 0, wayland_read_thread, NULL, 0, &id);
+
     return TRUE;
 }
 
-- 
2.35.1


From 2d3668779d994e9c6c3c752d0f08fe7d1925d447 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 13 Sep 2021 17:48:15 +0300
Subject: [PATCH 078/164] winewayland.drv: Prepare for handling windows with
 OpenGL/VK content.

Use a Wayland subsurface as the target surface for OpenGL/VK rendering
and support reconfiguring it appropriately. The toplevel Wayland surface
is used for all non-client rendering.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 218 +++++++++++++++++++++++--
 dlls/winewayland.drv/waylanddrv.h      |   7 +
 dlls/winewayland.drv/window.c          |  11 +-
 3 files changed, 220 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 41074114ef1..f30a2bf71cc 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -436,6 +436,9 @@ void wayland_surface_reconfigure_position(struct wayland_surface *surface,
  *
  * The coordinates and sizes should be given in wine's coordinate space.
  *
+ * Note that this doesn't configure any associated GL/VK subsurface,
+ * wayland_surface_reconfigure_glvk() needs to be called separately.
+ *
  * This function sets up but doesn't actually apply any new configuration.
  * The wayland_surface_reconfigure_apply() needs to be called for changes
  * to take effect.
@@ -511,21 +514,6 @@ void wayland_surface_reconfigure_size(struct wayland_surface *surface,
     }
 }
 
-/**********************************************************************
- *          wayland_surface_reconfigure_apply
- *
- * Applies the configuration set by previous calls to the
- * wayland_surface_reconfigure{_glvk}() functions.
- */
-void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
-{
-    wl_surface_commit(surface->wl_surface);
-
-    /* Commit the parent so any subsurface repositioning takes effect. */
-    if (surface->parent)
-        wl_surface_commit(surface->parent->wl_surface);
-}
-
 /**********************************************************************
  *          wayland_surface_configure_is_compatible
  *
@@ -741,6 +729,202 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     free(surface);
 }
 
+static struct wayland_surface *wayland_surface_create_glvk_common(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    glvk = wayland_surface_create_plain(surface->wayland);
+    if (!glvk)
+        goto err;
+
+    glvk->parent = wayland_surface_ref(surface);
+
+    /* Remove from toplevel_list (added as a plain surface) and add to parent
+     * child list. */
+    wl_list_remove(&glvk->link);
+    wayland_mutex_lock(&glvk->parent->mutex);
+    wl_list_insert(&glvk->parent->child_list, &glvk->link);
+    wayland_mutex_unlock(&glvk->parent->mutex);
+
+    glvk->wl_subsurface =
+        wl_subcompositor_get_subsurface(glvk->wayland->wl_subcompositor,
+                                        glvk->wl_surface,
+                                        surface->wl_surface);
+    if (!glvk->wl_subsurface)
+        goto err;
+    wl_subsurface_set_desync(glvk->wl_subsurface);
+    /* Place the glvk subsurface just above the parent surface, so that it
+     * doesn't end up obscuring any other subsurfaces. */
+    wl_subsurface_place_above(glvk->wl_subsurface, surface->wl_surface);
+
+    glvk->hwnd = surface->hwnd;
+    glvk->main_output = surface->main_output;
+    glvk->wine_output = surface->wine_output;
+    wl_surface_set_buffer_scale(glvk->wl_surface, wayland_surface_get_buffer_scale(surface));
+    glvk->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+
+    return glvk;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return NULL;
+}
+
+static struct wayland_surface *wayland_surface_ref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = NULL;
+    wayland_mutex_lock(&surface->mutex);
+    if (surface->glvk)
+        glvk = wayland_surface_ref(surface->glvk);
+    wayland_mutex_unlock(&surface->mutex);
+    return glvk;
+}
+
+/**********************************************************************
+ *          wayland_surface_create_glvk
+ *
+ * Creates a GL/VK subsurface for this wayland surface.
+ */
+BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk;
+    RECT client_rect;
+
+    TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
+
+    if (wayland_surface_ref_glvk(surface))
+        return TRUE;
+
+    glvk = wayland_surface_create_glvk_common(surface);
+    if (!glvk)
+        goto err;
+
+    wayland_mutex_lock(&surface->mutex);
+    surface->glvk = glvk;
+    wayland_mutex_unlock(&surface->mutex);
+
+    /* Set initial position in the client area. */
+    wayland_get_client_rect_in_win_coords(surface->hwnd, &client_rect);
+
+    wayland_surface_reconfigure_glvk(surface,
+                                     client_rect.left, client_rect.top,
+                                     client_rect.right - client_rect.left,
+                                     client_rect.bottom - client_rect.top);
+
+    wayland_surface_reconfigure_apply(surface);
+
+    return TRUE;
+
+err:
+    if (glvk)
+        wayland_surface_destroy(glvk);
+
+    return FALSE;
+}
+
+/**********************************************************************
+ *          wayland_surface_unref_glvk
+ *
+ * Unreferences the associated GL/VK subsurface for this wayland surface.
+ */
+void wayland_surface_unref_glvk(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk_to_destroy = NULL;
+    LONG ref = -12345;
+
+    wayland_mutex_lock(&surface->mutex);
+    if (surface->glvk && (ref = InterlockedDecrement(&surface->glvk->ref)) == 0)
+    {
+        glvk_to_destroy = surface->glvk;
+        surface->glvk = NULL;
+    }
+    TRACE("surface=%p glvk=%p ref=%d->%d\n",
+          surface, glvk_to_destroy ? glvk_to_destroy : surface->glvk, ref + 1, ref);
+    wayland_mutex_unlock(&surface->mutex);
+
+    if (glvk_to_destroy)
+        wayland_surface_destroy(glvk_to_destroy);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_glvk
+ *
+ * Configures the position and size of the GL/VK subsurface associated with
+ * a wayland surface.
+ *
+ * The coordinates and sizes should be given in wine's coordinate space.
+ *
+ * This function sets up but doesn't actually apply any new configuration.
+ * The wayland_surface_reconfigure_apply() needs to be called for changes
+ * to take effect.
+ */
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface,
+                                      int wine_x, int wine_y,
+                                      int wine_width, int wine_height)
+{
+    int x, y, width, height;
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (!glvk)
+        return;
+
+    wayland_surface_coords_rounded_from_wine(surface, wine_x, wine_y, &x, &y);
+    wayland_surface_coords_rounded_from_wine(surface, wine_width, wine_height,
+                                             &width, &height);
+
+    TRACE("surface=%p hwnd=%p %d,%d+%dx%d %d,%d+%dx%d\n",
+          surface, surface->hwnd,
+          wine_x, wine_y, wine_width, wine_height,
+          x, y, width, height);
+
+    glvk->offset_x = wine_x;
+    glvk->offset_y = wine_y;
+
+    wl_subsurface_set_position(glvk->wl_subsurface, x, y);
+
+    /* Use a viewport, if supported, to ensure GL surfaces remain inside their
+     * parent's boundaries when resizing and also to handle display mode
+     * changes. If the size is invalid use a 1x1 destination (instead of
+     * unsetting with -1x-1) since many apps don't respect a GL/VK 0x0 size
+     * which can happen, e.g., when an app is minimized. */
+    if (glvk->wp_viewport)
+    {
+        if (width != 0 && height != 0)
+            wp_viewport_set_destination(glvk->wp_viewport, width, height);
+        else
+            wp_viewport_set_destination(glvk->wp_viewport, 1, 1);
+    }
+
+    wayland_surface_unref_glvk(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure_apply
+ *
+ * Applies the configuration set by previous calls to the
+ * wayland_surface_reconfigure{_glvk}() functions.
+ */
+void wayland_surface_reconfigure_apply(struct wayland_surface *surface)
+{
+    struct wayland_surface *glvk = wayland_surface_ref_glvk(surface);
+
+    if (glvk)
+    {
+        wl_surface_commit(glvk->wl_surface);
+        wayland_surface_unref_glvk(surface);
+    }
+
+    wl_surface_commit(surface->wl_surface);
+
+    /* Commit the parent so any subsurface repositioning takes effect. */
+    if (surface->parent)
+        wl_surface_commit(surface->parent->wl_surface);
+}
+
 /**********************************************************************
  *          wayland_surface_unmap
  *
@@ -785,6 +969,10 @@ void wayland_surface_coords_to_screen(struct wayland_surface *surface,
 
     NtUserGetWindowRect(surface->hwnd, &window_rect);
 
+    /* Some wayland surfaces are offset relative to their window rect,
+     * e.g., GL subsurfaces. */
+    OffsetRect(&window_rect, surface->offset_x, surface->offset_y);
+
     *screen_x = wine_x + window_rect.left;
     *screen_y = wine_y + window_rect.top;
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 6293a059c56..919d648e74e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -214,6 +214,9 @@ struct wayland_surface
     struct xdg_toplevel *xdg_toplevel;
     struct wp_viewport *wp_viewport;
     struct wayland_surface *parent;
+    struct wayland_surface *glvk;
+    /* The offset of this surface relative to its owning win32 window */
+    int offset_x, offset_y;
     HWND hwnd;
     struct wayland_mutex mutex;
     struct wayland_surface_configure pending;
@@ -357,6 +360,10 @@ void wayland_surface_reconfigure_geometry(struct wayland_surface *surface,
 void wayland_surface_reconfigure_size(struct wayland_surface *surface,
                                       int width, int height) DECLSPEC_HIDDEN;
 void wayland_surface_reconfigure_apply(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+BOOL wayland_surface_create_or_ref_glvk(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_unref_glvk(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_reconfigure_glvk(struct wayland_surface *surface, int x, int y,
+                                      int width, int height) DECLSPEC_HIDDEN;
 void wayland_surface_unmap(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_coords_to_screen(struct wayland_surface *surface,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 59ee59009ba..7baed061afb 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -847,7 +847,16 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
                                              compat.bottom - compat.top);
     }
 
-    wayland_surface_reconfigure_apply(wsurface);
+    /* The GL/VK subsurface (if any), is positioned over the client area of the
+     * window. The position of the GL/VK subsurface is relative to the window
+     * top-left. */
+    wayland_surface_reconfigure_glvk(wsurface,
+                                     data->client_rect.left - data->window_rect.left,
+                                     data->client_rect.top - data->window_rect.top,
+                                     data->client_rect.right - data->client_rect.left,
+                                     data->client_rect.bottom - data->client_rect.top);
+
+    wayland_surface_reconfigure_apply(data->wayland_surface);
 
     if (wsurface->xdg_toplevel || wsurface->wl_subsurface)
         wsurface->drawing_allowed = TRUE;
-- 
2.35.1


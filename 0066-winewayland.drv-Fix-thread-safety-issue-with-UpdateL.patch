From 5726e0300d335aa77e0d69097a29b2d95bc6d882 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 14:25:25 +0300
Subject: [PATCH 066/165] winewayland.drv: Fix thread safety issue with
 UpdateLayeredWindow.

In some cases, notably when the app calls UpdateLayeredWindow, position
and size changes may be emitted from a thread other than the window
thread. Since in the current implementation updating the Wayland state
needs to happen in the context of the window thread to avoid racy
interactions, post a message to update the state in the right thread.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h |  1 +
 dlls/winewayland.drv/window.c     | 28 +++++++++++++++++++++++++++-
 2 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index ec4266c177b..7c33c0f0c09 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -59,6 +59,7 @@ enum wayland_window_message
     WM_WAYLAND_SET_CURSOR,
     WM_WAYLAND_QUERY_SURFACE_MAPPED,
     WM_WAYLAND_CONFIGURE,
+    WM_WAYLAND_STATE_UPDATE,
 };
 
 enum wayland_surface_role
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 5216be89be1..ac5097917f1 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -76,6 +76,8 @@ struct wayland_win_data
     RECT           old_window_rect;
     /* whether a wayland surface update is needed */
     BOOL           wayland_surface_needs_update;
+    /* Whether we have a pending/unprocessed WM_WAYLAND_STATE_UPDATE message */
+    BOOL           pending_state_update_message;
 };
 
 static struct wayland_mutex win_data_mutex =
@@ -979,7 +981,20 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
     data->pending_window_surface = surface;
     data->has_pending_window_surface = TRUE;
 
-    update_wayland_state(data);
+    /* In some cases, notably when the app calls UpdateLayeredWindow, position
+     * and size changes may be emitted from a thread other than the window
+     * thread. Since in the current implementation updating the wayland state
+     * needs to happen in the context of the window thread to avoid racy
+     * interactions, post a message to update the state in the right thread. */
+    if (GetCurrentThreadId() == NtUserGetWindowThread(hwnd, NULL))
+    {
+        update_wayland_state(data);
+    }
+    else if (!data->pending_state_update_message)
+    {
+        NtUserPostMessage(hwnd, WM_WAYLAND_STATE_UPDATE, 0, 0);
+        data->pending_state_update_message = TRUE;
+    }
 
     wayland_win_data_release(data);
 }
@@ -1436,6 +1451,17 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_surface_for_hwnd_unlock(wayland_surface);
         }
         break;
+    case WM_WAYLAND_STATE_UPDATE:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data)
+            {
+                data->pending_state_update_message = FALSE;
+                update_wayland_state(data);
+                wayland_win_data_release(data);
+            }
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.35.1


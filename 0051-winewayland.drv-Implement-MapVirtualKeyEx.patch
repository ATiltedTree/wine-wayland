From a3f3f8625f48e094a6a5be9f157eb65d6bf41ca2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 14:24:49 +0300
Subject: [PATCH 051/165] winewayland.drv: Implement MapVirtualKeyEx.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 171 ++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |   1 +
 dlls/winewayland.drv/waylanddrv_main.c  |   1 +
 3 files changed, 173 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 5c65e99737f..0fc9c6dd3ba 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -213,6 +213,44 @@ static xkb_keycode_t vkey_to_xkb_keycode(struct wayland_keyboard *keyboard, UINT
     return candidate;
 }
 
+static WORD vkey_to_scancode_fixed(UINT vkey)
+{
+    int i;
+    WORD scan = 0;
+
+    if (vkey == 0) return 0;
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_0xff00_to_vkey[i] == vkey &&
+            xkb_keysym_0xff00_to_scan[i] != 0)
+        {
+            scan = xkb_keysym_0xff00_to_scan[i];
+            if ((scan & 0xff00) == (vkey & 0xff00)) goto out;
+        }
+    }
+
+    for (i = 0; i <= 0xff; i++)
+    {
+        if (xkb_keysym_xfree86_to_vkey[i] == vkey &&
+            xkb_keysym_xfree86_to_scan[i] != 0)
+        {
+            scan = xkb_keysym_xfree86_to_scan[i];
+            if ((scan & 0xff00) == (vkey & 0xff00)) goto out;
+        }
+    }
+
+out:
+    return scan;
+}
+
+static WORD vkey_to_scancode(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    WORD scan = _xkb_keycode_to_scancode(keyboard, vkey_to_xkb_keycode(keyboard, vkey));
+    if (!scan || ((scan & 0xff00) != (vkey & 0xff00))) scan = vkey_to_scancode_fixed(vkey);
+    return scan;
+}
+
 static WORD scancode_to_vkey_fixed(UINT scan)
 {
     int i;
@@ -336,6 +374,27 @@ static WCHAR dead_xkb_keysym_to_wchar(xkb_keysym_t xkb_keysym)
     }
 }
 
+static WCHAR _xkb_keysyms_to_wchar(const xkb_keysym_t *syms, int nsyms)
+{
+    char utf8[64];
+    int utf8_len;
+    WCHAR wchars[8];
+    WCHAR normalized[8];
+    int normalized_len = ARRAY_SIZE(normalized);
+    int wbytes;
+
+    utf8_len = _xkb_keysyms_to_utf8(syms, nsyms, utf8, sizeof(utf8));
+
+    if (RtlUTF8ToUnicodeN(wchars, sizeof(wchars), (DWORD *)&wbytes, utf8, utf8_len))
+        return 0;
+
+    if (RtlNormalizeString(NormalizationC, wchars, wbytes / sizeof(WCHAR), normalized,
+                           &normalized_len) || normalized_len != 1)
+        return 0;
+
+    return normalized[0];
+}
+
 static BOOL _xkb_keycode_is_keypad_num(xkb_keycode_t xkb_keycode)
 {
     switch (xkb_keycode - 8)
@@ -387,6 +446,48 @@ static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
     return vkey;
 }
 
+static UINT map_vkey_to_wchar_with_deadchar_bit(struct wayland_keyboard *keyboard, UINT vkey)
+{
+    WCHAR wchar;
+    xkb_keycode_t xkb_keycode;
+    struct xkb_keymap *xkb_keymap;
+    xkb_layout_index_t layout;
+    const xkb_keysym_t *syms;
+    int nsyms;
+
+    if (!keyboard->xkb_state) return 0;
+
+    layout = _xkb_state_get_active_layout(keyboard->xkb_state);
+    if (layout == XKB_LAYOUT_INVALID)
+    {
+        TRACE_(key)("no active layout, returning wchar 0\n");
+        return 0;
+    }
+
+    xkb_keymap = xkb_state_get_keymap(keyboard->xkb_state);
+    xkb_keycode = vkey_to_xkb_keycode(keyboard, vkey);
+
+    nsyms = xkb_keymap_key_get_syms_by_level(xkb_keymap, xkb_keycode,
+                                             layout, 0, &syms);
+    if (nsyms > 0)
+    {
+        /* Set the high bit to 1 if this is dead char. */
+        if ((wchar = dead_xkb_keysym_to_wchar(syms[0])))
+            wchar |= 0x80000000;
+        else
+            wchar = _xkb_keysyms_to_wchar(syms, nsyms);
+    }
+    else
+    {
+        wchar = 0;
+    }
+
+    TRACE_(key)("vkey=0x%x xkb_keycode=%d nsyms=%d xkb_keysym[0]=0x%x => wchar=0x%x\n",
+                vkey, xkb_keycode, nsyms, nsyms ? syms[0] : 0, wchar);
+
+    return wchar;
+}
+
 static void wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t key,
                                   uint32_t state, HWND hwnd)
 {
@@ -926,3 +1027,73 @@ INT WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
     TRACE_(key)("lparam 0x%08x -> %s\n", lparam, debugstr_w(buffer));
     return len;
 }
+
+/***********************************************************************
+ *           WAYLAND_MapVirtualKeyEx
+ */
+UINT WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl)
+{
+    struct wayland *wayland = thread_init_wayland();
+    UINT ret = 0;
+
+    TRACE_(key)("code=0x%x, maptype=%d, hkl %p\n", code, maptype, hkl);
+
+    switch (maptype)
+    {
+    case MAPVK_VK_TO_VSC_EX:
+    case MAPVK_VK_TO_VSC:
+        /* vkey to scancode */
+        switch (code)
+        {
+        case VK_SHIFT:
+            code = VK_LSHIFT;
+            break;
+        case VK_CONTROL:
+            code = VK_LCONTROL;
+            break;
+        case VK_MENU:
+            code = VK_LMENU;
+            break;
+        }
+
+        if (maptype == MAPVK_VK_TO_VSC) code &= 0xff;
+        ret = vkey_to_scancode(&wayland->keyboard, code);
+        if (maptype == MAPVK_VK_TO_VSC)
+        {
+            UINT scan_prefix = (ret >> 8) & 0xff;
+            if (scan_prefix == 0xe1)
+                ret = 0;
+            else
+                ret &= 0xff;
+        }
+        break;
+    case MAPVK_VSC_TO_VK:
+    case MAPVK_VSC_TO_VK_EX:
+        /* scancode to vkey */
+        ret = scancode_to_vkey(&wayland->keyboard, code);
+        if (maptype == MAPVK_VSC_TO_VK)
+        {
+            switch (ret)
+            {
+            case VK_LSHIFT:
+            case VK_RSHIFT:
+                ret = VK_SHIFT; break;
+            case VK_LCONTROL:
+            case VK_RCONTROL:
+                ret = VK_CONTROL; break;
+            case VK_LMENU:
+            case VK_RMENU:
+                ret = VK_MENU; break;
+            }
+        }
+        break;
+    case MAPVK_VK_TO_CHAR:
+        ret = map_vkey_to_wchar_with_deadchar_bit(&wayland->keyboard, code);
+        break;
+    default:
+        FIXME("Unknown maptype %d\n", maptype);
+        break;
+    }
+    TRACE_(key)("returning 0x%04x\n", ret);
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7ae033d9113..71e5b671ac7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -447,6 +447,7 @@ BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 BOOL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
 INT WAYLAND_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) DECLSPEC_HIDDEN;
+UINT WAYLAND_MapVirtualKeyEx(UINT code, UINT maptype, HKL hkl) DECLSPEC_HIDDEN;
 NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 1c4b79a72eb..bd863eadfb0 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -122,6 +122,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
     .pGetKeyNameText = WAYLAND_GetKeyNameText,
+    .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
-- 
2.35.1


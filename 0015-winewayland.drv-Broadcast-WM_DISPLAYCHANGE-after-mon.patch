From 06f3158fffaa4910d30de04763b698849de61897 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 9 Nov 2021 19:22:04 +0200
Subject: [PATCH 015/165] winewayland.drv: Broadcast WM_DISPLAYCHANGE after
 monitor updates.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c    | 32 +++++++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h |  9 +++++++++
 dlls/winewayland.drv/window.c     |  4 ++++
 3 files changed, 45 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index be991272452..fca924dd7d2 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -43,9 +43,41 @@ static void wayland_refresh_display_devices(void)
     NtUserGetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &num_path, &num_mode);
 }
 
+static void wayland_broadcast_wm_display_change(void)
+{
+    struct wayland_output *output;
+    struct wayland *wayland = wayland_process_acquire();
+
+    /* During thread wayland initialization we will get our initial output
+     * information and init the display devices. There is no need to send out
+     * WM_DISPLAYCHANGE in this case, since this is the initial display state.
+     * Additionally, thread initialization may occur in a context that has
+     * acquired the internal Wine user32 lock, and sending messages would lead
+     * to an internal user32 lock error. */
+    if (wayland->initialized)
+    {
+        /* The first valid output is the primary. */
+        wl_list_for_each(output, &wayland->output_list, link)
+        {
+            int width, height;
+            if (!output->current_mode) continue;
+            width = output->current_mode->width;
+            height = output->current_mode->height;
+            wayland_process_release();
+
+            NtUserMessageCall(NtUserGetDesktopWindow(), WM_WAYLAND_BROADCAST_DISPLAY_CHANGE,
+                              32, MAKELPARAM(width, height), NULL, NtUserSendMessage, FALSE);
+            return;
+        }
+    }
+
+    wayland_process_release();
+}
+
 void wayland_init_display_devices()
 {
     wayland_refresh_display_devices();
+    wayland_broadcast_wm_display_change();
 }
 
 static void wayland_add_gpu(const struct gdi_device_manager *device_manager,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 488adcfe3e7..6ad4545e9f6 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -43,6 +43,15 @@
 
 extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
 
+/**********************************************************************
+  *          Internal messages and data
+  */
+
+enum wayland_window_message
+{
+    WM_WAYLAND_BROADCAST_DISPLAY_CHANGE = 0x80001000,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 6e57f470ea0..2f84b456670 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -57,6 +57,10 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 
     switch (msg)
     {
+    case WM_WAYLAND_BROADCAST_DISPLAY_CHANGE:
+        SendMessageTimeoutW(HWND_BROADCAST, WM_DISPLAYCHANGE, wp, lp,
+                            SMTO_ABORTIFHUNG, 2000, NULL);
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.35.1


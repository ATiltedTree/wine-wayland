From 5ce50af10f17a318e9b92d9c63e1f76af3034a5a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 15:53:46 +0300
Subject: [PATCH 063/165] winewayland.drv: Support window and window_surface
 regions.

Use buffers with an alpha channel (ARGB8888) to implement window
regions. Pixels outside the region are left as transparent in the
buffer.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   3 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          |  17 +++
 dlls/winewayland.drv/window_surface.c  | 172 +++++++++++++++++++++++--
 4 files changed, 181 insertions(+), 12 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 7ddeb0dca17..0a0b99958ad 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -391,6 +391,8 @@ void wayland_window_surface_flush(struct window_surface *window_surface) DECLSPE
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC_HIDDEN;
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -473,6 +475,7 @@ NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
 UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
 INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 379fe5179de..0babc999c37 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -125,6 +125,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pSetWindowRgn = WAYLAND_SetWindowRgn,
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ca4c0d4c9e4..4951fb98d33 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -997,6 +997,23 @@ UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
     return swp;
 }
 
+/***********************************************************************
+ *           WAYLAND_SetWindowRgn
+ */
+void WAYLAND_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
+{
+    struct wayland_win_data *data;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if ((data = wayland_win_data_get(hwnd)))
+    {
+        if (data->window_surface)
+            wayland_window_surface_set_window_region(data->window_surface, hrgn);
+        wayland_win_data_release(data);
+    }
+}
+
 static void handle_wm_wayland_monitor_change(struct wayland *wayland)
 {
     wayland_update_outputs_from_process(wayland);
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 80d5e392821..351a372b563 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -30,7 +30,7 @@
 #include <stdlib.h>
 
 #include "ntgdi.h"
-#include "winuser.h"
+#include "ntuser.h"
 
 #include "wine/debug.h"
 
@@ -43,6 +43,8 @@ struct wayland_window_surface
     struct wayland_surface *wayland_surface; /* Not owned by us */
     struct wayland_buffer_queue *wayland_buffer_queue;
     RECT                  bounds;
+    HRGN                  region; /* region set through window_surface funcs */
+    HRGN                  total_region; /* Total region (surface->region AND window_region) */
     void                 *bits;
     struct wayland_mutex  mutex;
     BOOL                  last_flush_failed;
@@ -72,6 +74,104 @@ static inline void reset_bounds(RECT *bounds)
     bounds->right = bounds->bottom = INT_MIN;
 }
 
+/***********************************************************************
+ *           wayland_window_surface_preferred_format
+ */
+static int get_preferred_format(struct wayland_window_surface *wws)
+{
+    int format;
+    HRGN window_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+
+    /* Use ARGB to implement window regions (areas out of the region are
+     * transparent). */
+    if ((window_region && NtUserGetWindowRgnEx(wws->hwnd, window_region, 0) != ERROR))
+        format = WL_SHM_FORMAT_ARGB8888;
+    else
+        format = WL_SHM_FORMAT_XRGB8888;
+
+    if (window_region) NtGdiDeleteObjectApp(window_region);
+
+    return format;
+}
+
+/***********************************************************************
+ *           recreate_wayland_buffer_queue
+ */
+static void recreate_wayland_buffer_queue(struct wayland_window_surface *wws)
+{
+    int width;
+    int height;
+    int format;
+
+    if (!wws->wayland_buffer_queue || !wws->wayland_surface) return;
+
+    width = wws->wayland_buffer_queue->width;
+    height = wws->wayland_buffer_queue->height;
+    format = get_preferred_format(wws);
+
+    wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+
+    wws->wayland_buffer_queue =
+        wayland_buffer_queue_create(wws->wayland_surface->wayland,
+                                    width, height, format);
+}
+
+/***********************************************************************
+ *           wayland_window_surface_set_window_region
+ */
+void wayland_window_surface_set_window_region(struct window_surface *window_surface,
+                                              HRGN win_region)
+{
+    struct wayland_window_surface *wws =
+        wayland_window_surface_cast(window_surface);
+    HRGN region = 0;
+
+    TRACE("hwnd %p surface %p region %p\n", wws->hwnd, wws, win_region);
+
+    if (win_region == (HRGN)1)  /* hack: win_region == 1 means retrieve region from server */
+    {
+        region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (region && NtUserGetWindowRgnEx(wws->hwnd, region, 0) == ERROR)
+        {
+            NtGdiDeleteObjectApp(region);
+            region = 0;
+        }
+    }
+    else if (win_region)
+    {
+        region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (region) NtGdiCombineRgn(region, win_region, 0, RGN_COPY);
+    }
+
+    if (wws->region)
+    {
+        if (region)
+        {
+            NtGdiCombineRgn(region, region, wws->region, RGN_AND);
+        }
+        else
+        {
+            region = NtGdiCreateRectRgn(0, 0, 0, 0);
+            if (region) NtGdiCombineRgn(region, wws->region, 0, RGN_COPY);
+        }
+    }
+
+    window_surface->funcs->lock(window_surface);
+
+    if (wws->total_region) NtGdiDeleteObjectApp(wws->total_region);
+    wws->total_region = region;
+    *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
+    /* Unconditionally recreate the buffer queue to ensure we have clean buffers, so
+     * that areas outside the region are transparent. */
+    recreate_wayland_buffer_queue(wws);
+
+    TRACE("hwnd %p bounds %s rect %s\n", wws->hwnd,
+          wine_dbgstr_rect(window_surface->funcs->get_bounds(window_surface)),
+          wine_dbgstr_rect(&wws->header.rect));
+
+    window_surface->funcs->unlock(window_surface);
+}
+
 /***********************************************************************
  *           wayland_window_surface_lock
  */
@@ -118,7 +218,23 @@ static RECT *wayland_window_surface_get_bounds(struct window_surface *window_sur
 static void wayland_window_surface_set_region(struct window_surface *window_surface,
                                               HRGN region)
 {
-    /* TODO */
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("updating hwnd=%p surface=%p region=%p\n", wws->hwnd, wws, region);
+
+    window_surface->funcs->lock(window_surface);
+    if (!region)
+    {
+        if (wws->region) NtGdiDeleteObjectApp(wws->region);
+        wws->region = NULL;
+    }
+    else
+    {
+        if (!wws->region) wws->region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        NtGdiCombineRgn(wws->region, region, 0, RGN_COPY);
+    }
+    window_surface->funcs->unlock(window_surface);
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
 }
 
 /***********************************************************************
@@ -141,6 +257,24 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
           wine_dbgstr_rect(&wws->header.rect), wine_dbgstr_rect(&wws->bounds));
 
     needs_flush = IntersectRect(&damage_rect, &wws->header.rect, &wws->bounds);
+    if (needs_flush)
+    {
+        RECT total_region_box;
+        surface_damage_region = NtGdiCreateRectRgn(damage_rect.left, damage_rect.top,
+                                                   damage_rect.right, damage_rect.bottom);
+        /* If the total_region is empty we are guaranteed to have empty SHM
+         * buffers. In order for this empty content to take effect, we still
+         * need to commit with non-empty damage, so don't AND with the
+         * total_region in this case, to ensure we don't end up with an empty
+         * surface_damage_region. */
+        if (wws->total_region &&
+            NtGdiGetRgnBox(wws->total_region, &total_region_box) != NULLREGION)
+        {
+            needs_flush = NtGdiCombineRgn(surface_damage_region, surface_damage_region,
+                                          wws->total_region, RGN_AND);
+        }
+    }
+
     if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
     {
         TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
@@ -152,12 +286,9 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
 
     if (!needs_flush) goto done;
 
-    surface_damage_region = NtGdiCreateRectRgn(damage_rect.left, damage_rect.top,
-                                               damage_rect.right, damage_rect.bottom);
-
-    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p\n",
+    TRACE("flushing surface %p hwnd %p surface_rect %s bits %p region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits);
+          wws->bits, wws->total_region);
 
     assert(wws->wayland_buffer_queue);
 
@@ -169,7 +300,7 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
         wws->last_flush_failed = TRUE;
         goto done;
     }
-    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, NULL);
+    buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
 
     rgn_rect = (RECT *)buffer_damage->Buffer;
     rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
@@ -178,7 +309,8 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
     for (;rgn_rect < rgn_rect_end; rgn_rect++)
     {
         unsigned int *src, *dst;
-        int y, width, height;
+        int x, y, width, height;
+        BOOL apply_surface_alpha;
 
         TRACE("damage %s\n", wine_dbgstr_rect(rgn_rect));
 
@@ -194,8 +326,13 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
         width = min(rgn_rect->right, buffer->width) - rgn_rect->left;
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
+        /* If we have an ARGB buffer we need to explicitly apply the surface
+         * alpha (assumed to be 255 currently) to ensure the destination has
+         * sensible alpha values. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
+
         /* Fast path for full width rectangles. */
-        if (width == buffer->width)
+        if (width == buffer->width && !apply_surface_alpha)
         {
             memcpy(dst, src, height * buffer->stride);
             continue;
@@ -203,7 +340,15 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
 
         for (y = 0; y < height; y++)
         {
-            memcpy(dst, src, width * 4);
+            if (!apply_surface_alpha)
+            {
+                memcpy(dst, src, width * 4);
+            }
+            else
+            {
+                for (x = 0; x < width; x++)
+                    dst[x] = 0xff000000 | src[x];
+            }
 
             src += wws->info.bmiHeader.biWidth;
             dst = (unsigned int*)((unsigned char*)dst + buffer->stride);
@@ -236,6 +381,8 @@ static void wayland_window_surface_destroy(struct window_surface *window_surface
     TRACE("surface=%p\n", wws);
 
     wayland_mutex_destroy(&wws->mutex);
+    if (wws->region) NtGdiDeleteObjectApp(wws->region);
+    if (wws->total_region) NtGdiDeleteObjectApp(wws->total_region);
     if (wws->wayland_surface) wayland_surface_unref(wws->wayland_surface);
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
@@ -281,6 +428,7 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->header.rect  = *rect;
     wws->header.ref   = 1;
     wws->hwnd         = hwnd;
+    wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
     if (!(wws->bits = malloc(wws->info.bmiHeader.biSizeImage)))
@@ -326,7 +474,7 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
         wws->wayland_buffer_queue =
             wayland_buffer_queue_create(wws->wayland_surface->wayland,
                     wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
-                    WL_SHM_FORMAT_XRGB8888);
+                    get_preferred_format(wws));
     }
     else if (!wws->wayland_surface && wws->wayland_buffer_queue)
     {
-- 
2.35.1


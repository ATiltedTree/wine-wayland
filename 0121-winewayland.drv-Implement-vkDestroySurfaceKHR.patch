From 8de4c4b1b955c180a2ef0247a1c4070a496263ae Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 17 Sep 2021 12:02:59 +0300
Subject: [PATCH 121/164] winewayland.drv: Implement vkDestroySurfaceKHR.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 37 +++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 524507dc6b8..d6d53ca8bc3 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -51,6 +51,7 @@ typedef struct VkWaylandSurfaceCreateInfoKHR
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
 static VkResult (*pvkCreateWaylandSurfaceKHR)(VkInstance, const VkWaylandSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
 static void (*pvkDestroyInstance)(VkInstance, const VkAllocationCallbacks *);
+static void (*pvkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 
 static void *vulkan_handle;
 
@@ -93,6 +94,22 @@ static void wine_vk_surface_destroy(struct wine_vk_surface *wine_vk_surface)
     free(wine_vk_surface);
 }
 
+static struct wine_vk_surface *wine_vk_surface_from_handle(VkSurfaceKHR handle)
+{
+    struct wine_vk_surface *surf;
+
+    wayland_mutex_lock(&wine_vk_object_mutex);
+
+    wl_list_for_each(surf, &wine_vk_surface_list, link)
+        if (surf->native_vk_surface == handle) goto out;
+
+    surf = NULL;
+
+out:
+    wayland_mutex_unlock(&wine_vk_object_mutex);
+    return surf;
+}
+
 /* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
  * Caller is responsible for allocation and cleanup of 'dst'.
  */
@@ -244,6 +261,24 @@ static void wayland_vkDestroyInstance(VkInstance instance, const VkAllocationCal
     pvkDestroyInstance(instance, NULL /* allocator */);
 }
 
+static void wayland_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface,
+                                        const VkAllocationCallbacks *allocator)
+{
+    struct wine_vk_surface *wine_vk_surface = wine_vk_surface_from_handle(surface);
+
+    TRACE("%p 0x%s %p\n", instance, wine_dbgstr_longlong(surface), allocator);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    if (wine_vk_surface)
+    {
+        pvkDestroySurfaceKHR(instance, wine_vk_surface->native_vk_surface,
+                             NULL /* allocator */);
+        wine_vk_surface_destroy(wine_vk_surface);
+    }
+}
+
 static void wine_vk_init(void)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
@@ -256,6 +291,7 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateWaylandSurfaceKHR);
     LOAD_FUNCPTR(vkDestroyInstance);
+    LOAD_FUNCPTR(vkDestroySurfaceKHR);
 #undef LOAD_FUNCPTR
 
     return;
@@ -270,6 +306,7 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkCreateInstance = wayland_vkCreateInstance,
     .p_vkCreateWin32SurfaceKHR = wayland_vkCreateWin32SurfaceKHR,
     .p_vkDestroyInstance = wayland_vkDestroyInstance,
+    .p_vkDestroySurfaceKHR = wayland_vkDestroySurfaceKHR,
 };
 
 /**********************************************************************
-- 
2.35.1


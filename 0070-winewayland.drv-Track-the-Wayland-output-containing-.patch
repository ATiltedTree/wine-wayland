From 8a0a8cb1d24c879f528a2c31aec21db9ea87d86a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 26 Oct 2021 13:16:38 +0300
Subject: [PATCH 070/165] winewayland.drv: Track the Wayland output containing
 a window.

Track the output Wine considers to contain the window backed by a
surface. Transiently, this may be different from the output we consider
to be the "main" one for this surface. We will use this information in
upcoming commits to make an educated guess about which Wayland output a
surface will be displayed on, in case the Wayland compositor has not yet
sent the relevant output enter event(s) for a surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         |  4 +++
 dlls/winewayland.drv/wayland_surface.c | 38 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 ++
 dlls/winewayland.drv/window.c          |  2 ++
 4 files changed, 47 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 6c0bf9e8a22..334237efed6 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -178,7 +178,11 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
             /* Remove the output from toplevels, as some compositors don't send
              * a leave event if the output is disconnected. */
             wl_list_for_each(surface, &wayland->toplevel_list, link)
+            {
                 wayland_surface_leave_output(surface, output);
+                if (surface->wine_output == output)
+                    wayland_surface_set_wine_output(surface, NULL);
+            }
 
             wayland_output_destroy(output);
             if (wayland_is_process(wayland))
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index fc5c3049fe0..a0649b5001a 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -329,6 +329,7 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
     wl_subsurface_set_desync(surface->wl_subsurface);
 
     surface->main_output = parent->main_output;
+    surface->wine_output = parent->wine_output;
 
     wl_surface_commit(surface->wl_surface);
 
@@ -877,3 +878,40 @@ void wayland_surface_leave_output(struct wayland_surface *surface,
         wayland_surface_set_main_output(surface, origin);
     }
 }
+
+static void wayland_surface_tree_set_wine_output(struct wayland_surface *surface,
+                                                 struct wayland_output *output)
+{
+    struct wayland_surface *child;
+
+    surface->wine_output = output;
+
+    wayland_mutex_lock(&surface->mutex);
+
+    wl_list_for_each(child, &surface->child_list, link)
+        wayland_surface_tree_set_wine_output(child, output);
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
+/**********************************************************************
+ *          wayland_surface_set_wine_output
+ *
+ * Sets the output which Wine considers to contain the window backed by this
+ * surface. Transiently, this may be different from the output we consider to
+ * be the "main" one for this surface.
+ */
+void wayland_surface_set_wine_output(struct wayland_surface *surface,
+                                     struct wayland_output *output)
+{
+    /* Don't update non-toplevels. */
+    if (surface->parent) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->wine_output ? surface->wine_output->name : NULL,
+          output ? output->name : NULL);
+
+    if (surface->wine_output != output)
+        wayland_surface_tree_set_wine_output(surface, output);
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 0228b85fe63..f67b3f8529c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -215,6 +215,7 @@ struct wayland_surface
     enum wayland_surface_role role;
     struct wl_list output_ref_list;
     struct wayland_output *main_output;
+    struct wayland_output *wine_output;
     BOOL drawing_allowed;
     struct wl_list child_list;
 };
@@ -362,6 +363,8 @@ struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DEC
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_leave_output(struct wayland_surface *surface,
                                   struct wayland_output *output) DECLSPEC_HIDDEN;
+void wayland_surface_set_wine_output(struct wayland_surface *surface,
+                                     struct wayland_output *output) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland native buffer
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index fb2bc28ef9c..93380f29ec1 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -601,6 +601,8 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
           mi.rcMonitor.bottom - mi.rcMonitor.top,
           data->maximized, data->fullscreen, data->handling_wayland_configure_event);
 
+    wayland_surface_set_wine_output(data->wayland_surface, output);
+
     /* If we are currently handling a wayland configure event (i.e., we are
      * being called through handle_wm_wayland_configure() -> SetWindowPos()),
      * use the event configure flags directly. Otherwise try to infer the flags
-- 
2.35.1


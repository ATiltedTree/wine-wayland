From 8fa3ac547d06963af4202799b04e354397c057c1 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 8 Nov 2021 12:34:39 +0200
Subject: [PATCH 010/165] winewayland.drv: Maintain a per-process wayland
 instance.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c    | 58 ++++++++++++++++++++++++++++---
 dlls/winewayland.drv/waylanddrv.h |  3 ++
 2 files changed, 56 insertions(+), 5 deletions(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index fc7140501d8..9139bdeed61 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -24,9 +24,16 @@
 
 #include "wine/debug.h"
 
+#include <stdlib.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 struct wl_display *process_wl_display = NULL;
+static struct wayland *process_wayland = NULL;
+static struct wayland_mutex process_wayland_mutex =
+{
+    PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP, 0, 0, __FILE__ ": process_wayland_mutex"
+};
 
 static struct wayland_mutex thread_wayland_mutex =
 {
@@ -119,10 +126,13 @@ BOOL wayland_init(struct wayland *wayland)
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
 
-    /* Keep a list of all thread wayland instances. */
-    wayland_mutex_lock(&thread_wayland_mutex);
-    wl_list_insert(&thread_wayland_list, &wayland->thread_link);
-    wayland_mutex_unlock(&thread_wayland_mutex);
+    if (!wayland_is_process(wayland))
+    {
+        /* Keep a list of all thread wayland instances. */
+        wayland_mutex_lock(&thread_wayland_mutex);
+        wl_list_insert(&thread_wayland_list, &wayland->thread_link);
+        wayland_mutex_unlock(&thread_wayland_mutex);
+    }
 
     wayland->initialized = TRUE;
 
@@ -165,5 +175,43 @@ void wayland_deinit(struct wayland *wayland)
 BOOL wayland_process_init(void)
 {
     process_wl_display = wl_display_connect(NULL);
-    return process_wl_display != NULL;
+    if (!process_wl_display)
+        return FALSE;
+
+    process_wayland = calloc(1, sizeof(*process_wayland));
+    if (!process_wayland)
+        return FALSE;
+
+    return wayland_init(process_wayland);
+}
+
+/**********************************************************************
+ *          wayland_is_process
+ *
+ *  Checks whether a wayland instance is the per-process one.
+ */
+BOOL wayland_is_process(struct wayland *wayland)
+{
+    return wayland == process_wayland;
+}
+
+/**********************************************************************
+ *          wayland_process_acquire
+ *
+ *  Acquires the per-process wayland instance.
+ */
+struct wayland *wayland_process_acquire(void)
+{
+    wayland_mutex_lock(&process_wayland_mutex);
+    return process_wayland;
+}
+
+/**********************************************************************
+ *          wayland_process_release
+ *
+ *  Releases the per-process wayland instance.
+ */
+void wayland_process_release(void)
+{
+    wayland_mutex_unlock(&process_wayland_mutex);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index f7be5670667..b7b4443f545 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -98,6 +98,9 @@ static inline struct wayland *thread_wayland(void)
 BOOL wayland_process_init(void) DECLSPEC_HIDDEN;
 BOOL wayland_init(struct wayland *wayland) DECLSPEC_HIDDEN;
 void wayland_deinit(struct wayland *wayland) DECLSPEC_HIDDEN;
+BOOL wayland_is_process(struct wayland *wayland) DECLSPEC_HIDDEN;
+struct wayland *wayland_process_acquire(void) DECLSPEC_HIDDEN;
+void wayland_process_release(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland mutex
-- 
2.35.1

